# SDD 방법론 -- 스펙 주도 개발 (Spec-Driven Development)

## SDD란?

스펙 주도 개발 (SDD)은 **스펙이 전체 개발 라이프사이클의 단일 진실 소스**가 되는 소프트웨어 개발 방법론입니다. 모든 코드는 스펙 항목으로 추적 가능해야 하며, 품질은 주관적 리뷰가 아닌 스펙 준수 체크리스트로 측정됩니다.

## 핵심 원칙

### 1. 구현 전 스펙 작성

스펙이 승인되기 전까지 코드를 작성하지 않습니다. 이를 통해 다음을 방지합니다:
- 기능 범위 확장 (Feature creep)
- 잘못된 구현
- 불필요한 재작업

### 2. 체크리스트를 품질 게이트로 활용

스펙 준수 체크리스트가 유일한 품질 기준입니다. 각 항목은 다음 조건을 충족해야 합니다:
- **검증 가능**: 코드를 읽어서 확인할 수 있어야 함
- **원자적**: 하나의 항목 = 하나의 검증 가능한 사항
- **추적 가능**: 특정 스펙 섹션을 참조해야 함

### 3. 책임 기반의 병렬 실행

작업은 병렬로 실행 가능한 독립적인 워크 패키지로 분해됩니다. 각 워크 패키지는 다음을 포함합니다:
- 명시적인 스펙 참조
- 할당된 체크리스트 항목
- 명확한 완료 기준

### 4. 리더 주도의 품질 루프

팀 리더가 구체적이고 실행 가능한 피드백을 통해 체크리스트 완료를 검증합니다. 루프 동작:
1. 스펙 참조와 함께 작업 할당
2. 체크리스트 대비 완료 여부 검증
3. 미완료 항목에 대한 구체적인 피드백 제공
4. 반복 실패 시 에스컬레이션

## 7단계 라이프사이클

### 1단계: 요구사항 수집 (Intake)

**목표**: 모든 요구사항을 수집하고 구조화합니다.

**소스**: Confluence 페이지, Jira 에픽, Figma 디자인, 로컬 문서, 대화형 인터뷰.

**산출물**: `01-requirements.md` — 기능 요구사항(FR-001), 비기능 요구사항(NFR-001), 제약 조건, 가정 사항을 번호 매겨 정리합니다.

### 2단계: 스펙 작성 (Spec)

**목표**: 요구사항을 정밀한 기술 스펙으로 변환합니다.

**신규 프로젝트의 경우**:
- 시스템 아키텍처 (기술 스택, 모듈, 의존성)
- API 스펙 (엔드포인트, 스키마, 에러 코드)
- 데이터 모델 (엔티티, 필드, 관계, 인덱스)
- 컴포넌트 분해 (책임, 인터페이스)
- 스펙 준수 체크리스트

**레거시 프로젝트의 경우**:
- 변경 영향 분석 (영향받는 모듈, 리스크)
- API 변경 사항 (신규, 수정, 삭제 엔드포인트)
- 데이터 마이그레이션 (스키마 변경, 마이그레이션 전략)
- 컴포넌트 변경 사항 (수정 모듈, 의존성)
- 스펙 준수 체크리스트

### 3단계: 계획 수립 (Plan)

**목표**: 스펙을 병렬 실행 가능한 워크 패키지로 분해합니다.

각 워크 패키지에 포함되는 내용:
- 스펙 참조가 있는 태스크 목록
- 할당된 체크리스트 항목
- 다른 워크 패키지와의 의존성
- 팀 멤버 구성

### 4단계: 구현 (Build)

**목표**: 품질 관리를 적용하며 모든 워크 패키지를 구현합니다.

품질 루프:
```
할당 --> 구현 --> 검증 --> [재작업 | 승인]
```

에스컬레이션까지 최대 3회 재작업 사이클.

**레거시 프로젝트 (분석 전용 경로)**: 레거시 모드에서는 빌드 단계에서 코드를 수정하지 않고 **분석만** 수행합니다. 기존 코드를 스펙과 대조하여 충족 항목은 `[x]`로 표시하고, 미충족 항목은 갭으로 식별합니다. 결과는 `10-analysis-report.md`에 기록되며, 식별된 갭은 `/claude-sdd:sdd-change` 워크플로우(`--from-analysis` 플래그)를 통해 해소합니다.

### 5단계: 리뷰 (Review)

**목표**: 종합 품질 게이트 검증.

각 체크리스트 항목에 대해:
1. 코드가 존재하는가?
2. 스펙과 일치하는가?
3. 테스트가 있는가?

결과: 각 항목별 PASS, FAIL, 또는 PARTIAL.

### 6단계: 통합 (Integrate)

**목표**: 추적 가능한 풀 리퀘스트를 생성합니다.

포함 사항:
- 전체 테스트 실행
- 문서 업데이트
- 스펙 추적 테이블이 포함된 PR

### 7단계: 문서화 (Document)

**목표**: 모든 문서가 구현 내용을 반영하도록 합니다.

CHANGELOG, README, 스펙 문서를 최종 상태로 업데이트합니다.

### 8단계: 변경 관리 (Change) — 선택

**목표**: 통합 완료 후 변경 요청을 체계적으로 처리합니다.

변경 관리 사이클:
1. 변경 요청 수집 및 분석
2. 기존 스펙 대비 영향 범위 식별
3. 체크리스트 부분 갱신 (최소 영향 원칙)
4. TDD 방식으로 델타 빌드 및 회귀 검증
5. 변경 추적성이 포함된 PR 생성

## 프로젝트 규칙 (Project Rules)

SDD 방법론에서 프로젝트 규칙은 "어떻게 구현할 것인가"를 정의합니다. 체크리스트가 "무엇을 구현할 것인가(What)"를 추적한다면, 프로젝트 규칙은 "어떻게 구현할 것인가(How)"를 강제합니다.

### 규칙의 역할

- 스펙과 체크리스트 사이의 간극을 메움
- 에이전트가 일관된 코드 스타일을 유지하도록 강제
- 코드 리뷰에서 주관적 판단을 배제하고 규칙 기반 검증

### 4필드 구조

각 규칙은 원칙(principle), 위반 기준(violation criteria), 검증 방법(verification method), 예외(exceptions)로 구성됩니다. 이 구조는 에이전트가 자동으로 검증할 수 있는 명확한 기준을 제공합니다.

## TDD (테스트 주도 개발) 통합

SDD는 선택적으로 TDD 모드를 지원합니다. `--tdd` 플래그 또는 `sdd-config.yaml`의 `teams.tdd: true`로 활성화합니다.

### TDD 빌드 루프

```
Phase A (Red):   sdd-test-writer가 스펙에서 실패하는 테스트를 작성
Phase B (Green): sdd-implementer가 테스트를 통과하는 코드를 작성
Phase C (Verify): 전체 테스트를 실행하여 통과 확인
```

### TDD 핵심 원칙

1. **테스트와 구현의 분리**: `sdd-test-writer`는 테스트만, `sdd-implementer`는 구현만 담당
2. **테스트 수정 금지**: 구현자는 테스트 파일을 절대 수정하지 않음
3. **스펙 기반 테스트**: 추측이 아닌 스펙에 명시된 동작만 테스트
4. **체크리스트 항목 매핑**: 각 체크리스트 항목당 최소 1개 테스트

## 신규 프로젝트 vs 레거시 프로젝트 워크플로우

| 관점 | 신규 프로젝트 (Greenfield) | 레거시 프로젝트 (Brownfield) |
|------|---------------------------|------------------------------|
| 아키텍처 | 처음부터 설계 | 변경 영향 분석 |
| API | 전체 스펙 작성 | 변경 사항만 (신규/수정/삭제) |
| 데이터 | 전체 모델 설계 | 마이그레이션 계획 |
| 컴포넌트 | 전체 분해 | 변경 분석 |
| 빌드 모드 | 구현 + 품질 루프 | 분석 전용 (코드 수정 없음) |
| 갭 해소 | 빌드 단계에서 직접 구현 | `sdd-change` 워크플로우로 처리 |
| 리스크 | 낮음 (기존 코드 없음) | 높음 (하위 호환성 필요) |

## 체크리스트 카테고리

| 카테고리 | 설명 | 예시 |
|----------|------|------|
| ARCH | 아키텍처 | 모듈 구조가 스펙과 일치 |
| API | API | 엔드포인트가 올바른 스키마를 반환 |
| DM | 데이터 모델 | 엔티티가 명시된 모든 필드를 보유 |
| COMP | 컴포넌트 | 모듈이 명시된 인터페이스를 구현 |
| TEST | 테스트 | 공개 함수에 대한 단위 테스트 존재 |
| SEC | 보안 | 입력 검증이 구현됨 |
| PERF | 성능 | 쿼리가 명시된 인덱스를 사용 |
| UI | UI | 컴포넌트가 명시된 요소를 렌더링 |
| CHG | 변경 | 변경 요청으로 추가된 항목 |
| CHG-REG | 회귀 | 기존 기능 보존을 검증하는 항목 |

## 장점

1. **추적 가능성**: 모든 코드 변경이 스펙 항목에 매핑됩니다.
2. **예측 가능성**: 진행 상황을 객관적으로 측정합니다 (0%에서 100%).
3. **병렬 처리**: 독립적인 워크 패키지가 동시에 실행됩니다.
4. **품질 보증**: 주관적 의견이 아닌 스펙 기반의 자동 검증.
5. **책임 소재**: 워크 패키지와 체크리스트 항목에 대한 명확한 소유권.
